/*
포인터를 사용하는 이유는 다음과 같이 3가지 용도에서 잘 사용되기 때문이다.
1. 자유 기억 장소의 자료를 다룰 때
2. 클래스 멤버 자료와 클래스 멤버 함수에 접근할 때
3. 함수에 주소 전달을 할 때
*/
/*
자유 기억 공간(heap)이란, 다량의 메모리 집합으로 생각하면 되는데, 거기에는 자료 넣기를 기다리는 순차적인 번호가 붙은 방들이 수 업싱 있다.
여기에는 스택과 같이 꼬리표를 붙일 수 없다.
하지만 여기에는 비축해 놓은 방들의 주소를 원할 수 있고, 이 주소를 포인터에 저장할 수 있다.

스택의 내용은 함수가 반환되면 자동적으로 지워진다.
모든 지역 변수는 범위 규칙을 벗어나게 되고 그들은 스택에서 지워진다.
자유 기억 공간은 프로그램을 끝낼 때까지 지워지지 않는다.
메모리 사용을 끝냈을 때 그 공간을 유지하느냐 버리느냐를 결정해야 한다.

자유 기억 공간(heap)에서는 이 공간을 제거할 때까지는 보관된다는 것이다.
어느 함수에서 자유 기억공간에 메모리를 할당해 놓으면 그 함수가 끝나도 그 공간을 할당되어 있다.
이러한 방식으로 메모리에 접근하는 방법이 전역 변수를 사용하는 것보다 좋은 점은, 단지 그 포인터에 접근할 수 있는 함수만이 자료에 접근할 수 있다는 것이다.
이런 방식은 해당 자료에 철저히 통제된 방식의 인터페이스를 제공하고, 함수가 대책 없는 방향으로 자료 바꾸는 것을 막아준다.

new라는 예약어를 통해 자유기억공간에 메모리를 할당하고
delete를 통하여 포인터를 반환해야 한다.
프로그램이 끝나기 전까지 메모리는 자동적으로 해제되지 않는다. 따라서 이 메모리 부분은 쓰일 수 없게되어야 하며,
이 상황을 가리켜 메모리 누출이라고 부르고, 프로그램이 끝나기 전까지 이 메모리는 쓰일 수 없기 때문에 메모리 누출이라고 불리는 것이다.

delete의 역할은 포인터에 저장된 주소의 메모리가 자유 기억 장소로 다시 반환되는 것이다.
이 포인터가 가리키던 메모리를 자유 기억 장소로 반환하라고 말하는 것이다.
이때 포인터는 그대로 포인터이고 여기에 다른 값을 할당할 수 있다.
*/

#include <iostream>

int main(void)
{
	using namespace std;
	int localVariable=5;
	int *pLocal = &localVariable;
	int *pHeap = new int;
	*pHeap=7;
	cout << "localVariable : " << localVariable << endl;
	cout << "*pLocal : " << *pLocal << endl;
	cout << "*pHeap : " << *pHeap << endl;
	//delete pHeap;
	pHeap = new int;
	*pHeap = 11;
	cout << "*pheap : " << *pHeap <<endl;
	delete pHeap;
	pHeap = NULL;
	return 0;
}

/*
여기서 만약 메모리 누출이 일어나는 상황은 어떤 때 인지 생각해보자
pHeap을 new예약어를 통해 할당을 받아 놓은다음, 그 메모리 공간에 7이라는 데이터를 입력하였다.
그런데 만약 delete를 하지 않은 상태에서 새로운 new를 한다고 하면, 메모리 유출(Memory Leak)이 발생한다.
왜 그런 것일까? => 그 이유는 원래의 영역에 7이라는 값이 지금 저장되어 있는 원래 포인터에 다른 메모리 번지의 
주소가 들어가는 것이기 때문에 사용할 수 없다. 원래 메모리에 접근할 방법이 없고 프로그램이 끝날 때 까지 그 영역을 해제할 방법도 없다.
delete pHeap을 주석처리로 하여 프로그램을 돌려보면 돌아갈 수 있다. 하지만 처음에 들어간 pHeap의 주소 위치를 알 수 없기때문에,
메모리의 주소의 행방불명을 야기할 수 있다. 이런 방식을 미연에 방지하기위해 항상 새로운 메모리할당을 할때는 지워준 다음에 사용하도록 하자.
*/